/**
 * Game Action Catch-All API Route — POST /api/game/[action]
 *
 * 将所有游戏控制 API 子路由合并到一个 serverless function 中，
 * 共享同一实例 + 同一 postgres 连接池，消除跨 route 冷启动。
 * 根据 [action] path parameter 分派到对应的处理逻辑。
 *
 * 支持的 action：
 *   assign, clear-seats, fill-bots, mark-bots-viewed, restart,
 *   seat, set-animation, share-review, start, update-template, view-role
 *
 * 负责请求解析与分派到对应 handler，不直接操作 DB / state，不播放音频。
 */

import type { VercelRequest, VercelResponse } from '@vercel/node';
import {
  type AudioEffect,
  type GameState,
  handleAssignRoles,
  handleClearAllSeats,
  handleFillWithBots,
  handleJoinSeat,
  handleLeaveMySeat,
  handleMarkAllBotsViewed,
  handleRestartGame,
  handleSetRoleRevealAnimation,
  handleShareNightReview,
  handleStartNight,
  handleUpdateTemplate,
  handleViewedRole,
  type JoinSeatIntent,
  type LeaveMySeatIntent,
  type StateAction,
} from '@werewolf/game-engine';

import { handleCors } from '../_lib/cors';
import { processGameAction } from '../_lib/gameStateManager';
import { buildHandlerContext } from '../_lib/handlerContext';
import { resultToStatus } from '../_lib/responseStatus';
import type {
  SeatRequestBody,
  SetAnimationRequestBody,
  ShareReviewRequestBody,
  StartRequestBody,
  UpdateTemplateRequestBody,
  ViewRoleRequestBody,
} from '../_lib/types';

// ---------------------------------------------------------------------------
// Shared helpers (DRY)
// ---------------------------------------------------------------------------

/** Respond with 400 MISSING_PARAMS */
function missingParams(res: VercelResponse) {
  return res.status(400).json({ success: false, reason: 'MISSING_PARAMS' });
}

/**
 * Factory for simple handlers that only need roomCode.
 *
 * Pattern: extract body → validate → processGameAction → buildHandlerContext(state, state.hostUid) → handlerFn → respond.
 * Host 鉴权由路由层完成（传入 state.hostUid 保证只有 host 能执行这些操作）。
 */
function createSimpleHandler<I extends { type: string }>(
  handlerFn: (
    intent: I,
    ctx: ReturnType<typeof buildHandlerContext>,
  ) => ReturnType<typeof handleAssignRoles>,
  intent: I,
) {
  return async (req: VercelRequest, res: VercelResponse) => {
    const body = req.body as { roomCode?: string };
    const { roomCode } = body;
    if (!roomCode) return missingParams(res);

    const result = await processGameAction(roomCode, (state: GameState) => {
      const handlerCtx = buildHandlerContext(state, state.hostUid);
      return handlerFn(intent, handlerCtx);
    });
    return res.status(resultToStatus(result)).json(result);
  };
}

// ---------------------------------------------------------------------------
// Simple handlers (generated by factory)
// ---------------------------------------------------------------------------

const handleAssign = createSimpleHandler(handleAssignRoles, { type: 'ASSIGN_ROLES' as const });
const handleFillBots = createSimpleHandler(handleFillWithBots, {
  type: 'FILL_WITH_BOTS' as const,
});
const handleMarkBotsViewed = createSimpleHandler(handleMarkAllBotsViewed, {
  type: 'MARK_ALL_BOTS_VIEWED' as const,
});
const handleClearSeats = createSimpleHandler(handleClearAllSeats, {
  type: 'CLEAR_ALL_SEATS' as const,
});
const handleRestart = createSimpleHandler(handleRestartGame, { type: 'RESTART_GAME' as const });

async function handleSeat(req: VercelRequest, res: VercelResponse) {
  const body = req.body as SeatRequestBody;
  const { roomCode, action, uid, seat, displayName, avatarUrl } = body;

  if (!roomCode || !uid || !action) {
    return missingParams(res);
  }

  if (action !== 'sit' && action !== 'standup') {
    return res.status(400).json({ success: false, reason: 'INVALID_ACTION' });
  }

  if (action === 'sit' && (seat == null || typeof seat !== 'number')) {
    return res.status(400).json({ success: false, reason: 'MISSING_SEAT' });
  }

  const result = await processGameAction(roomCode, (state: GameState) => {
    const handlerCtx = buildHandlerContext(state, uid);
    if (action === 'sit') {
      const intent: JoinSeatIntent = {
        type: 'JOIN_SEAT',
        payload: { seat: seat!, uid, displayName: displayName ?? '', avatarUrl },
      };
      return handleJoinSeat(intent, handlerCtx);
    } else {
      const intent: LeaveMySeatIntent = {
        type: 'LEAVE_MY_SEAT',
        payload: { uid },
      };
      return handleLeaveMySeat(intent, handlerCtx);
    }
  });
  return res.status(resultToStatus(result)).json(result);
}

async function handleSetAnimation(req: VercelRequest, res: VercelResponse) {
  const body = req.body as SetAnimationRequestBody;
  const { roomCode, animation } = body;

  if (!roomCode || !animation) {
    return missingParams(res);
  }

  const result = await processGameAction(roomCode, (state: GameState) => {
    const handlerCtx = buildHandlerContext(state, state.hostUid);
    return handleSetRoleRevealAnimation(
      { type: 'SET_ROLE_REVEAL_ANIMATION', animation },
      handlerCtx,
    );
  });
  return res.status(resultToStatus(result)).json(result);
}

async function handleStart(req: VercelRequest, res: VercelResponse) {
  const body = req.body as StartRequestBody;
  const { roomCode } = body;

  if (!roomCode) {
    return missingParams(res);
  }

  const result = await processGameAction(roomCode, (state: GameState) => {
    const handlerCtx = buildHandlerContext(state, state.hostUid);
    const handlerResult = handleStartNight({ type: 'START_NIGHT' }, handlerCtx);
    if (!handlerResult.success) return handlerResult;

    const audioEffects: AudioEffect[] = (handlerResult.sideEffects ?? [])
      .filter(
        (e): e is { type: 'PLAY_AUDIO'; audioKey: string; isEndAudio?: boolean } =>
          e.type === 'PLAY_AUDIO',
      )
      .map((e) => ({ audioKey: e.audioKey, isEndAudio: e.isEndAudio }));

    if (audioEffects.length > 0) {
      const extraActions: StateAction[] = [
        { type: 'SET_PENDING_AUDIO_EFFECTS', payload: { effects: audioEffects } },
        { type: 'SET_AUDIO_PLAYING', payload: { isPlaying: true } },
      ];
      return {
        ...handlerResult,
        actions: [...handlerResult.actions, ...extraActions],
      };
    }

    return handlerResult;
  });
  return res.status(resultToStatus(result)).json(result);
}

async function handleUpdateTemplateRoute(req: VercelRequest, res: VercelResponse) {
  const body = req.body as UpdateTemplateRequestBody;
  const { roomCode, templateRoles } = body;

  if (!roomCode || !templateRoles || !Array.isArray(templateRoles)) {
    return missingParams(res);
  }

  const result = await processGameAction(roomCode, (state: GameState) => {
    const handlerCtx = buildHandlerContext(state, state.hostUid);
    return handleUpdateTemplate(
      { type: 'UPDATE_TEMPLATE', payload: { templateRoles } },
      handlerCtx,
    );
  });
  return res.status(resultToStatus(result)).json(result);
}

async function handleViewRole(req: VercelRequest, res: VercelResponse) {
  const body = req.body as ViewRoleRequestBody;
  const { roomCode, uid, seat } = body;

  if (!roomCode || !uid || typeof seat !== 'number') {
    return missingParams(res);
  }

  const result = await processGameAction(roomCode, (state: GameState) => {
    const handlerCtx = buildHandlerContext(state, uid);
    return handleViewedRole({ type: 'VIEWED_ROLE', payload: { seat } }, handlerCtx);
  });
  return res.status(resultToStatus(result)).json(result);
}

async function handleShareReview(req: VercelRequest, res: VercelResponse) {
  const body = req.body as ShareReviewRequestBody;
  const { roomCode, allowedSeats } = body;

  if (!roomCode || !Array.isArray(allowedSeats)) {
    return missingParams(res);
  }

  const result = await processGameAction(roomCode, (state: GameState) => {
    const handlerCtx = buildHandlerContext(state, state.hostUid);
    return handleShareNightReview({ type: 'SHARE_NIGHT_REVIEW', allowedSeats }, handlerCtx);
  });
  return res.status(resultToStatus(result)).json(result);
}

// ---------------------------------------------------------------------------
// Dispatcher
// ---------------------------------------------------------------------------

const ROUTE_MAP: Record<
  string,
  (req: VercelRequest, res: VercelResponse) => Promise<VercelResponse | void>
> = {
  assign: handleAssign,
  'clear-seats': handleClearSeats,
  'fill-bots': handleFillBots,
  'mark-bots-viewed': handleMarkBotsViewed,
  restart: handleRestart,
  seat: handleSeat,
  'set-animation': handleSetAnimation,
  'share-review': handleShareReview,
  start: handleStart,
  'update-template': handleUpdateTemplateRoute,
  'view-role': handleViewRole,
};

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (handleCors(req, res)) return;
  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, reason: 'METHOD_NOT_ALLOWED' });
  }

  const actionName = req.query.action;
  if (typeof actionName !== 'string' || !ROUTE_MAP[actionName]) {
    return res.status(404).json({ success: false, reason: 'UNKNOWN_ACTION' });
  }

  return ROUTE_MAP[actionName](req, res);
}
